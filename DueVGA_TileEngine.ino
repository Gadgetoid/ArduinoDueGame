/*
  This is a basic tile based game engine using
  a 20x16 grid of tiles, of values 0 to 255,
  each of which can have a function-based fragment
  shader accepting x and y values.
  
  The engine determines the tile it's rendering and
  calls its fragment shader function with the x and y
  values of that tile.
  
  It will also supply that tiles global x/y coords
*/
#include <VGA.h>

#define RESX 320
#define RESY 240
#define LEVEL_WIDTH 20
#define LEVEL_HEIGHT 15
#define TILE_SIZE 16
#define TILE_BEVEL 2
#define BACKGROUND_COLOR 0x6E
#define SHADOW_COLOR 0x00
#define LEVEL_DEPTH 2
#define SPRITE_HEADER_SIZE 3

unsigned char (*tile_fragment_shader[4])(int x, int y, int p_x, int p_y, int fragment_col) = {
  &tile_empty,
  &tile_solid,
  &tile_shadow,
  &tile_bevel
};

int player_x = 10,
    player_y = 208,
    player_frame = 0;

/*
  This is a colour palette, it should be
  addressed with a 1 based index of range
  1 to 15. Index 0 is reserved for transparent
*/
static unsigned char player_palette[15] = {
  0x83,0x87,0x8B,0x8F,0x93,
  0x97,0x9B,0x9F,0x82,0x86,
  0x8A,0x8E,0x92,0x96,0x20
};

/* 
  This is a 15-colour, paletized, packed
  player sprite with 1 frame.
  
  Colour 0 = transparent.
*/
static unsigned char player[259] = {
 16,  // Width
 16,  // Height
 2,   // Frame Count
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x00,
 0x00,0x00,0x0F,0xAF,0xFA,0xF0,0x00,0x00,
 0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0x0F,0xF0,0x00,0x00,0x00,
 0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x00,
 0x00,0x00,0x0F,0xAF,0xFA,0xF0,0x00,0x00,
 0x00,0x00,0x0F,0xFF,0xFF,0xF0,0x00,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0x0F,0xF0,0x00,0x00,0x00,
 0x00,0x00,0xFF,0xFF,0xFF,0xFF,0x00,0x00,
 0x00,0xFF,0x00,0xFF,0xFF,0x00,0xFF,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0xFF,0xFF,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x00,0xF0,0x0F,0x00,0x00,0x00,
 0x00,0x00,0x0F,0x00,0x0F,0x00,0x00,0x00,
 0x00,0x00,0xF0,0x00,0x0F,0x00,0x00,0x00,
 0x00,0x00,0xF0,0x00,0x0F,0x00,0x00,0x00,
 0x00,0x00,0xF0,0x00,0x0F,0x00,0x00,0x00
};

static unsigned char bg[LEVEL_WIDTH*LEVEL_HEIGHT] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
  0x00,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};
static unsigned char mg[LEVEL_WIDTH*LEVEL_HEIGHT] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,
  0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03
};
static unsigned char fg[LEVEL_WIDTH*LEVEL_HEIGHT] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

unsigned char tile_solid(int x, int y, int p_x, int p_y, int fragment_col){
  return 255;
}
unsigned char tile_shadow(int x, int y, int p_x, int p_y, int fragment_col){
  if(y%2){
    return x%2?SHADOW_COLOR:fragment_col;
  }
  else
  {
    return x%2?fragment_col:SHADOW_COLOR;
  }
}
unsigned char tile_bevel(int x, int y, int p_x, int p_y, int fragment_col){
 if(y < TILE_BEVEL && x>=y){
  return 0x7F;
 } 
 if(y > TILE_SIZE-TILE_BEVEL-1){
   return 0x6F;
 }
 if(x < TILE_BEVEL){
  return 0x7B; 
 }
 if(x > TILE_SIZE-TILE_BEVEL-1){
  return 0x73; 
 }
 return 0x77;
}
unsigned char tile_empty(int x, int y, int p_x, int p_y, int fragment_col){
  return fragment_col;
}

unsigned char paint_player(int player_frame,int player_x, int player_y, int pixel_x, int pixel_y, int fragment_col){
  int player_width = player[0],
      player_height = player[1];
      
  // Ensure the pixel is within the bounds of the player
  if(
    pixel_x >= player_x && pixel_y >= player_y
    && pixel_x < player_x + player_width
    && pixel_y < player_y + player_height
   ){
    
    
     int p_x = (pixel_x - player_x),
         p_y = (pixel_y - player_y),
         p_i,
         p_frame_offset = 0;
         
     p_i = (player_width * p_y) + p_x;
     
     if(player_frame>0) p_frame_offset = (player_frame*player_width*player_height)/2;
         
     unsigned char pixel = p_i % 2 ? player[(int)floor(p_i/2)+SPRITE_HEADER_SIZE+p_frame_offset] & 0xf : (player[(int)floor(p_i/2)+SPRITE_HEADER_SIZE+p_frame_offset] >> 4) & 0xf;
     
     return pixel==0 ? fragment_col : player_palette[pixel-1];
     
  }
  return fragment_col;
}

/*unsigned char get_tile_at(int x,int y,int z){
  int tile_x = floor(x/TILE_SIZE),
      tile_y = floor(y/TILE_SIZE);
  
  return level[z][(tile_y*LEVEL_WIDTH)+tile_x];
}*/

unsigned char get_tile_fragment(int x,int y){
  int tile_x = floor(x/TILE_SIZE),
      tile_y = floor(y/TILE_SIZE),
      tile_i = (tile_y*LEVEL_WIDTH)+tile_x,
      // Get our x/y coords within the tile
      f_x = x % TILE_SIZE,
      f_y = y % TILE_SIZE;

  // Build up our fragment from the background colour
  // TODO: Grab initial pixel from a bitmap backdrop
  unsigned char tile_fragment = BACKGROUND_COLOR;
  
   // unsigned char tile_id = get_tile_at(x,y,z);
  
  // Pass them to the correct fragment shader
  
  //for(int z = 0;z<LEVEL_DEPTH;z++){
    unsigned char tile_id = bg[tile_i];
    if( tile_id > 0 ) tile_fragment = tile_fragment_shader[tile_id](f_x,f_y,tile_x,tile_y,tile_fragment);
    
    unsigned char last_tile_fragment = tile_fragment;
    
    tile_id = mg[tile_i];
    if( tile_id > 0 ) tile_fragment = tile_fragment_shader[tile_id](f_x,f_y,tile_x,tile_y,tile_fragment);
    
    // Solid!
    if( tile_fragment != last_tile_fragment){
      
    }
    
    // Paint player here
    tile_fragment = paint_player(player_frame,player_x,player_y,x,y,tile_fragment);
    
    tile_id = fg[tile_i];
    if( tile_id > 0 ) tile_fragment = tile_fragment_shader[tile_id](f_x,f_y,tile_x,tile_y,tile_fragment);
  //}
  
  return tile_fragment;
}

void redraw_rect(int rect_x,int rect_y,int width,int height){
  for(int x=0;x<width;x++)
  {
    for(int y=0;y<height;y++)
    {
      VGA.putCPixelFast(
        x+rect_x,
        y+rect_y,
        get_tile_fragment(x+rect_x,y+rect_y)
      );
    }
  }
}

int s = 0;

void setup() {
  int fragment_col = BACKGROUND_COLOR;
  VGA.begin(RESX,RESY,VGA_COLOUR);
  
  for(int x = 0;x<RESX;x++){
    for(int y = 0;y<RESY;y++){
      VGA.putCPixelFast(
        x,
        y,
        get_tile_fragment(x,y)
      );
    }
  }
  /*
  for(int x = 0;x<RESX;x++){
    double h = map(x,0,319,0,360);
    for(int y = 0;y<RESY;y++){
      double v = map(y,0,239,0,100);
      VGA.putCPixelFast(
        x,
        y,
        hsv_to_rgb(h,100,v)
      );
    }
  }*/
}

void loop() {
  int last_x = player_x,
      last_y = player_y;
  player_x++;

  if(player_x + player[0] > RESX){
   player_x = 0; 
  }
  
  redraw_rect(last_x,last_y,player[0],player[1]);
  redraw_rect(player_x,player_y,player[0],player[1]);
  
  player_frame++;
  
  if(player_frame > player[2]){
   player_frame = 0; 
  }
}

/*
  Converts HSV to RRRGGGBB
  Values:
    H: 0 to 360
    S: 0 to 100
    V: 0 to 100
*/
unsigned char hsv_to_rgb(int H, int S, int V) 
{
  int r, g, b;
  int f, w, q, t, i;
  
  if( S == 0 ) return (round(V*0.07)<<5) + (round(V*0.07)<<2) + round(V * 0.03);

  i = H/60;
  f = (((H * 100) / 60) - (i * 100));
  w = V * (100 - S) / 100;
  q = V * (100 * 100 - (S * f)) / 10000;
  t = V * (100 * 100 - (S * (100 - f))) / 10000;
  switch( i ) {
    case 0: case 6: r = V, g = t, b = w; break;
    case 1: r = q, g = V, b = w; break;
    case 2: r = w, g = V, b = t; break;
    case 3: r = w, g = q, b = V; break;
    case 4: r = t, g = w, b = V; break;
    case 5: r = V, g = w, b = q; break;
  }
  return (round(r*0.07)<<5) + (round(g*0.07)<<2) + round(b * 0.03);
}
