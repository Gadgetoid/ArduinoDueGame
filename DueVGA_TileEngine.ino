/*
  This is an example of HSV to 8-bit colour,
  implemented mostly in integer maths for speed
  
  8-bit colour, RRRGGGBB, is suitable for use
  with the DueVGA library.
*/
#include <VGA.h>

#define RESX 320
#define RESY 240
#define LEVEL_WIDTH 20
#define LEVEL_HEIGHT 15
#define TILE_SIZE 16
#define TILE_BEVEL 2
#define BACKGROUND_COLOR 0x6E
#define SHADOW_COLOR 0x00

unsigned char (*tile_fragment_shader[4])(int x,int y) = {
  &tile_empty,
  &tile_solid,
  &tile_shadow,
  &tile_bevel
};

static unsigned char level[300] = {
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x03,0x03,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x02,0x02,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
};

unsigned char tile_solid(int x, int y){
  return 255;
}
unsigned char tile_shadow(int x, int y){
  if(y%2){
    return x%2?SHADOW_COLOR:BACKGROUND_COLOR;
  }
  else
  {
    return x%2?BACKGROUND_COLOR:SHADOW_COLOR;
  }
}
unsigned char tile_bevel(int x, int y){
 if(y < TILE_BEVEL){
  return 0x7F;
 } 
 if(y > TILE_SIZE-TILE_BEVEL-1){
   return 0x6F;
 }
 if(x < TILE_BEVEL){
  return 0x7B; 
 }
 if(x > TILE_SIZE-TILE_BEVEL-1){
  return 0x73; 
 }
 return 0x77;
}
unsigned char tile_empty(int x, int y){
  return BACKGROUND_COLOR;
}

unsigned char get_tile_at(int x,int y){
  int tile_x = floor(x/TILE_SIZE),
      tile_y = floor(y/TILE_SIZE);
  
  return level[(tile_y*LEVEL_WIDTH)+tile_x];
}

unsigned char get_tile_fragment(int x,int y){
  unsigned char tile_id = get_tile_at(x,y);
  
  // Get our x/y coords within the tile
  int f_x = x % TILE_SIZE;
  int f_y = y % TILE_SIZE;
  
  // Pass them to the correct fragment shader
  return tile_fragment_shader[tile_id](f_x,f_y);
}

int s = 0;

void setup() {
  VGA.begin(RESX,RESY,VGA_COLOUR); 
  for(int x = 0;x<RESX;x++){
    for(int y = 0;y<RESY;y++){
      VGA.putCPixelFast(
        x,
        y,
        get_tile_fragment(x,y)
      );
    }
  }
  /*
  for(int x = 0;x<RESX;x++){
    double h = map(x,0,319,0,360);
    for(int y = 0;y<RESY;y++){
      double v = map(y,0,239,0,100);
      VGA.putCPixelFast(
        x,
        y,
        hsv_to_rgb(h,100,v)
      );
    }
  }*/
}

void loop() {
}

/*
  Converts HSV to RRRGGGBB
  Values:
    H: 0 to 360
    S: 0 to 100
    V: 0 to 100
*/
unsigned char hsv_to_rgb(int H, int S, int V) 
{
  int r, g, b;
  int f, w, q, t, i;
  
  if( S == 0 ) return (round(V*0.07)<<5) + (round(V*0.07)<<2) + round(V * 0.03);

  i = H/60;
  f = (((H * 100) / 60) - (i * 100));
  w = V * (100 - S) / 100;
  q = V * (100 * 100 - (S * f)) / 10000;
  t = V * (100 * 100 - (S * (100 - f))) / 10000;
  switch( i ) {
    case 0: case 6: r = V, g = t, b = w; break;
    case 1: r = q, g = V, b = w; break;
    case 2: r = w, g = V, b = t; break;
    case 3: r = w, g = q, b = V; break;
    case 4: r = t, g = w, b = V; break;
    case 5: r = V, g = w, b = q; break;
  }
  return (round(r*0.07)<<5) + (round(g*0.07)<<2) + round(b * 0.03);
}
